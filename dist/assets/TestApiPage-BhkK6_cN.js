import{a as T,_ as w,r as f,c as b,b as l,d as A,w as m,v as h,t as y,o as R}from"./index-B5FDxn-G.js";const L="5b3ce3597851110001cf6248367b86bb45f4468cb4c2fa4ebb0dfc05";class D{constructor(n=L){this.apiKey=n}async getRoute(n,t){try{console.log(`Attempting to calculate route from (${n.lat}, ${n.lng}) to (${t.lat}, ${t.lng})...`);try{console.log("Trying OpenRouteService API first...");const a=await T.post("/ors-api/v2/directions/driving-car",{coordinates:[[n.lng,n.lat],[t.lng,t.lat]],options:{avoid_features:["ferries"],avoid_borders:"controlled"},format:"geojson",units:"km"},{headers:{Authorization:`Bearer ${this.apiKey}`,"Content-Type":"application/json; charset=utf-8",Accept:"application/json, application/geo+json, application/gpx+xml"},timeout:8e3});if(a.data&&a.data.features&&a.data.features.length>0){console.log("OpenRouteService API call successful!");const o=a.data.features[0],r=o.properties,s=o.geometry;return{distance:r.summary.distance,duration:r.summary.duration,geometry:this.formatRouteGeometry(s)}}throw new Error("No route found in API response")}catch(a){return console.warn("OpenRouteService API error:",a.message),console.log("Using fallback routing method instead..."),this.fallbackGetRoute(n,t)}}catch(a){return console.error("Error in route calculation:",a),this.fallbackGetRoute(n,t)}}fallbackGetRoute(n,t){console.log("Using fallback routing method...");const a=this.calculateDistance(n,t),r=a/50*3600,s=this.generateSimpleRoute(n,t);return{distance:a*1e3,duration:r,geometry:s}}generateSimpleRoute(n,t){const a=[];a.push({...n});const o=this.calculateDistance(n,t),r=Math.max(2,Math.ceil(o*2));for(let s=1;s<r-1;s++){const i=s/(r-1),d=n.lat+(t.lat-n.lat)*i,c=n.lng+(t.lng-n.lng)*i,g=.001,v=d+(Math.random()*2-1)*g,P=c+(Math.random()*2-1)*g,u={lat:v,lng:P},e=this.fallbackSnapToRoad(u);a.push(e)}return a.push({...t}),a}formatRouteGeometry(n){return!n||!n.coordinates?[]:n.coordinates.map(t=>({lat:t[1],lng:t[0]}))}async snapToRoad(n){try{console.log(`Attempting to snap point (${n.lat}, ${n.lng}) to road...`);const t=await T.post("/ors-api/v2/snap/driving-car",{locations:[[n.lng,n.lat]],radius:100},{headers:{Authorization:`Bearer ${this.apiKey}`,"Content-Type":"application/json; charset=utf-8",Accept:"application/json, application/geo+json"},timeout:5e3});if(t.data&&t.data.locations&&t.data.locations.length>0){console.log("Road snapping successful using dedicated snap endpoint!");const a=t.data.locations[0].location;return{lat:a[1],lng:a[0]}}else if(t.data&&t.data.snapped_coordinates&&t.data.snapped_coordinates.length>0){console.log("Road snapping successful using snapped_coordinates format!");const a=t.data.snapped_coordinates[0];return{lat:a[1],lng:a[0]}}else if(t.data&&t.data.features&&t.data.features.length>0){console.log("Road snapping successful using GeoJSON format!");const a=t.data.features[0].geometry.coordinates;return{lat:a[1],lng:a[0]}}return console.warn("No snapped point found in API response, using fallback..."),this.fallbackSnapToRoad(n)}catch(t){console.warn("Error snapping to road with API:",t.message);try{return console.log("Trying to snap using directions API as fallback..."),await this.snapToRoadUsingDirections(n)}catch{return console.log("Directions API fallback also failed, using geometric fallback algorithm..."),this.fallbackSnapToRoad(n)}}}fallbackSnapToRoad(n){const t=[{start:{lat:38.7223,lng:-9.1393},end:{lat:38.7268,lng:-9.1503}},{start:{lat:38.7268,lng:-9.1503},end:{lat:38.7317,lng:-9.1377}},{start:{lat:38.7317,lng:-9.1377},end:{lat:38.7372,lng:-9.1328}},{start:{lat:38.7372,lng:-9.1328},end:{lat:38.7476,lng:-9.1467}},{start:{lat:38.7103,lng:-9.1321},end:{lat:38.7223,lng:-9.1393}},{start:{lat:38.7103,lng:-9.1321},end:{lat:38.7118,lng:-9.1418}},{start:{lat:38.7223,lng:-9.1623},end:{lat:38.7208,lng:-9.1783}},{start:{lat:38.7208,lng:-9.1783},end:{lat:38.7197,lng:-9.1922}},{start:{lat:38.7197,lng:-9.1922},end:{lat:38.7186,lng:-9.2088}},{start:{lat:38.7186,lng:-9.2088},end:{lat:38.7163,lng:-9.2254}},{start:{lat:38.7659,lng:-9.1183},end:{lat:38.7765,lng:-9.1148}},{start:{lat:38.7765,lng:-9.1148},end:{lat:38.7857,lng:-9.1099}},{start:{lat:38.7857,lng:-9.1099},end:{lat:38.7939,lng:-9.1026}},{start:{lat:38.6969,lng:-9.2055},end:{lat:38.6978,lng:-9.1969}},{start:{lat:38.6978,lng:-9.1969},end:{lat:38.6985,lng:-9.1901}},{start:{lat:38.6985,lng:-9.1901},end:{lat:38.6994,lng:-9.1823}},{start:{lat:38.7507,lng:-9.19},end:{lat:38.7547,lng:-9.1947}},{start:{lat:38.7547,lng:-9.1947},end:{lat:38.7593,lng:-9.1987}},{start:{lat:38.7593,lng:-9.1987},end:{lat:38.763,lng:-9.2025}},{start:{lat:38.75,lng:-9.185},end:{lat:38.7507,lng:-9.19}},{start:{lat:38.7547,lng:-9.1947},end:{lat:38.75,lng:-9.197}},{start:{lat:38.75,lng:-9.197},end:{lat:38.745,lng:-9.2}},{start:{lat:38.745,lng:-9.2},end:{lat:38.74,lng:-9.203}},{start:{lat:38.74,lng:-9.203},end:{lat:38.735,lng:-9.205}}];let a={...n},o=Number.MAX_VALUE;for(const r of t){const s=this.snapPointToSegment(n,r.start,r.end),i=this.calculateDistance(n,s);i<o&&(o=i,a=s)}return o<=.5?a:n}snapPointToSegment(n,t,a){const o=n.lng,r=n.lat,s=t.lng,i=t.lat,d=a.lng,c=a.lat,g=(d-s)*(d-s)+(c-i)*(c-i);if(g===0)return t;const v=((o-s)*(d-s)+(r-i)*(c-i))/g;return v<0?t:v>1?a:{lat:i+v*(c-i),lng:s+v*(d-s)}}calculateDistance(n,t){const o=this.deg2rad(t.lat-n.lat),r=this.deg2rad(t.lng-n.lng),s=Math.sin(o/2)*Math.sin(o/2)+Math.cos(this.deg2rad(n.lat))*Math.cos(this.deg2rad(t.lat))*Math.sin(r/2)*Math.sin(r/2);return 6371*(2*Math.atan2(Math.sqrt(s),Math.sqrt(1-s)))}deg2rad(n){return n*(Math.PI/180)}async snapToRoadUsingDirections(n){try{console.log("Attempting to snap point using directions API as fallback...");const t=await T.post("/ors-api/v2/directions/driving-car",{coordinates:[[n.lng,n.lat],[n.lng+1e-4,n.lat+1e-4]],format:"geojson",radiuses:[50,50]},{headers:{Authorization:`Bearer ${this.apiKey}`,"Content-Type":"application/json; charset=utf-8",Accept:"application/json, application/geo+json"},timeout:5e3});if(t.data&&t.data.features&&t.data.features.length>0){console.log("Road snapping successful using directions API fallback!");const a=t.data.features[0].geometry.coordinates[0];return{lat:a[1],lng:a[0]}}throw new Error("No route found in directions API response")}catch(t){throw console.warn("Error snapping to road with directions API:",t.message),t}}}const S=new D,I={class:"test-container"},M={class:"test-card"},E={class:"input-group"},j={class:"input-group"},U={key:0,class:"result"},x={key:1,class:"error"},G={class:"test-card"},N={class:"input-group"},O={class:"input-group"},_={class:"input-group"},V={class:"input-group"},$={key:0,class:"result"},B={key:1,class:"error"},C={__name:"TestApiPage",setup(k){const n=f(38.7223),t=f(-9.1393),a=f(null),o=f(null),r=f(38.7223),s=f(-9.1393),i=f(38.7476),d=f(-9.1467),c=f(null),g=f(null);async function v(){try{o.value=null,a.value=null,console.log("Testing snap to road with:",{lat:n.value,lng:t.value});const u=await S.snapToRoad({lat:n.value,lng:t.value});console.log("Snap to road result:",u),a.value=u}catch(u){console.error("Error in snap to road test:",u),o.value=u.toString(),u.response&&(o.value+=`

Response Data: `+JSON.stringify(u.response.data,null,2),o.value+=`
Status: `+u.response.status)}}async function P(){try{g.value=null,c.value=null,console.log("Testing get route with:",{origin:{lat:r.value,lng:s.value},destination:{lat:i.value,lng:d.value}});const u=await S.getRoute({lat:r.value,lng:s.value},{lat:i.value,lng:d.value});console.log("Get route result:",u),c.value=u}catch(u){console.error("Error in get route test:",u),g.value=u.toString(),u.response&&(g.value+=`

Response Data: `+JSON.stringify(u.response.data,null,2),g.value+=`
Status: `+u.response.status)}}return(u,e)=>(R(),b("div",I,[e[18]||(e[18]=l("h1",null,"OpenRouteService API Test",-1)),l("div",M,[e[10]||(e[10]=l("h2",null,"Test Snap to Road",-1)),l("div",E,[e[6]||(e[6]=l("label",null,"Latitude:",-1)),m(l("input",{"onUpdate:modelValue":e[0]||(e[0]=p=>n.value=p),type:"number",step:"0.0001"},null,512),[[h,n.value]])]),l("div",j,[e[7]||(e[7]=l("label",null,"Longitude:",-1)),m(l("input",{"onUpdate:modelValue":e[1]||(e[1]=p=>t.value=p),type:"number",step:"0.0001"},null,512),[[h,t.value]])]),l("button",{onClick:v,class:"test-button"},"Test Snap to Road"),a.value?(R(),b("div",U,[e[8]||(e[8]=l("h3",null,"Result:",-1)),l("pre",null,y(JSON.stringify(a.value,null,2)),1)])):A("",!0),o.value?(R(),b("div",x,[e[9]||(e[9]=l("h3",null,"Error:",-1)),l("pre",null,y(o.value),1)])):A("",!0)]),l("div",G,[e[17]||(e[17]=l("h2",null,"Test Get Route",-1)),l("div",N,[e[11]||(e[11]=l("label",null,"Origin Lat:",-1)),m(l("input",{"onUpdate:modelValue":e[2]||(e[2]=p=>r.value=p),type:"number",step:"0.0001"},null,512),[[h,r.value]])]),l("div",O,[e[12]||(e[12]=l("label",null,"Origin Lng:",-1)),m(l("input",{"onUpdate:modelValue":e[3]||(e[3]=p=>s.value=p),type:"number",step:"0.0001"},null,512),[[h,s.value]])]),l("div",_,[e[13]||(e[13]=l("label",null,"Destination Lat:",-1)),m(l("input",{"onUpdate:modelValue":e[4]||(e[4]=p=>i.value=p),type:"number",step:"0.0001"},null,512),[[h,i.value]])]),l("div",V,[e[14]||(e[14]=l("label",null,"Destination Lng:",-1)),m(l("input",{"onUpdate:modelValue":e[5]||(e[5]=p=>d.value=p),type:"number",step:"0.0001"},null,512),[[h,d.value]])]),l("button",{onClick:P,class:"test-button"},"Test Get Route"),c.value?(R(),b("div",$,[e[15]||(e[15]=l("h3",null,"Result:",-1)),l("p",null,"Distance: "+y(c.value.distance)+" meters",1),l("p",null,"Duration: "+y(c.value.duration)+" seconds",1),l("p",null,"Points: "+y(c.value.geometry.length),1)])):A("",!0),g.value?(R(),b("div",B,[e[16]||(e[16]=l("h3",null,"Error:",-1)),l("pre",null,y(g.value),1)])):A("",!0)])]))}},J=w(C,[["__scopeId","data-v-1d80283f"]]);export{J as default};
